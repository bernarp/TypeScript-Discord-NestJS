![TypeScript](https://img.shields.io/badge/typescript-%23007ACC.svg?style=for-the-badge&logo=typescript&logoColor=white)![Discord.js](https://img.shields.io/badge/Discord.js-%235865F2.svg?style=for-the-badge&logo=discord&logoColor=white)![NestJS](https://img.shields.io/badge/nestjs-%23E0234E.svg?style=for-the-badge&logo=nestjs&logoColor=white)
# Discord Бот на NestJS

## 1. Введение

Бот построен с использованием фреймворка **NestJS** и библиотеки **discord.js**. Проект спроектирован с упором на модульность, слабую связанность компонентов и расширяемость.

## 2. Подготовка к запуску

#### 2.1. Требования
*   **Node.js** (рекомендуется версия LTS, например, 18.x или 20.x)
*   **npm** или **yarn** в качестве пакетного менеджера

#### 2.2. Настройка Discord-приложения
1.  Перейдите на [Портал разработчиков Discord](https://discord.com/developers/applications).
2.  Создайте новое приложение (`New Application`).
3.  Перейдите во вкладку **"Bot"** и создайте бота (`Add Bot`).
4.  Скопируйте **токен** вашего бота (`Copy Token`). **Никогда не делитесь этим токеном и не публикуйте его!**
5.  Включите все три **Privileged Gateway Intents** (Presence, Server Members, Message Content). Это необходимо для корректной работы многих функций.
6.  Перейдите во вкладку **"OAuth2 -> URL Generator"**:
    *   Выберите скоупы `bot` и `applications.commands`.
    *   В разделе "Bot Permissions" выберите необходимые права (для тестов можно выбрать `Administrator`).
    *   Скопируйте сгенерированную URL и добавьте бота на ваш тестовый сервер.

#### 2.3. Конфигурация проекта
1.  Склонируйте репозиторий.
2.  Установите зависимости: `npm install` или `yarn install`.
3.  Создайте файл `.env` в корне проекта, скопировав содержимое из `.env.example`.
4.  Заполните файл `.env` вашими данными:
    *   `TOKEN`: Токен, который вы скопировали на портале разработчиков.
    *   `CLIENT_ID`: ID вашего приложения (находится на странице "General Information").
    *   `GUILD_ID`: ID вашего тестового сервера (включите режим разработчика в Discord, кликните правой кнопкой мыши по серверу и выберите "Копировать ID сервера").

## 3. Запуск
*   **Для разработки (с автоматической перезагрузкой):**
    ```bash
    npm run start:dev
    ```
*   **Для продакшена:**
    ```bash
    npm run build
    npm run start:prod
    ```

## 4. Ключевые архитектурные особенности

#### 4.1. Модульность и Внедрение зависимостей (DI)
Приложение разделено на независимые, функциональные модули NestJS. Каждый модуль (например, `GuildConfigModule`, `LoggingUserInteractionsGuildModule`) инкапсулирует определенную бизнес-логику. Фреймворк NestJS управляет жизненным циклом всех компонентов через встроенный контейнер Inversion of Control (IoC), автоматически внедряя зависимости через конструкторы.

#### 4.2. Многоуровневая система конфигурации
Система конфигурации была полностью переработана для максимальной гибкости и соответствия Принципу единственной ответственности. Она состоит из трех четких слоев:

1.  **Слой Стратегий Хранения (`IStorageStrategy`):** Абстрагирует физическое хранилище данных. Текущая реализация `JsonStorageStrategy` работает с локальными JSON-файлами, но ее можно легко заменить на стратегию для работы с базой данных без изменения остального кода.
2.  **Слой Репозиториев (`IPermissionRepository`, `IGuildSettingsRepository`):** Каждый репозиторий инкапсулирует логику работы с определенным типом данных (например, правами доступа или настройками гильдии), управляя кэшированием и доступом к данным.
3.  **Слой Фасада (`IConfigurationService`):** `ConfigurationService` выступает в роли единой точки входа (Фасада), предоставляя удобный и структурированный доступ ко всем репозиториям (`config.guilds`, `config.permissions`), но не содержит собственной бизнес-логики.

#### 4.3. Событийно-ориентированная архитектура (Event Bus)
Взаимодействие между различными частями приложения построено на асинхронной модели "Издатель-Подписчик" с использованием внутренней шины событий (`@nestjs/event-emitter`).

**Процесс работы:**
1.  `Client.ts` (слой-адаптер) прослушивает "сырые" события от Discord API.
2.  Получив событие, он оборачивает его в строго типизированный внутренний класс-событие (например, `MessageCreateEvent`) и отправляет в шину.
3.  Любой сервис в приложении подписывается на это внутреннее событие с помощью декоратора `@OnEvent`, реагируя на него.

#### 4.4. Декларативная модель и метапрограммирование
Проект активно использует кастомные декораторы для упрощения кода и отделения сквозной функциональности (cross-cutting concerns).

*   **`@Command()` и `@Button()`:** Эти декораторы помечают классы как обработчики команд или кнопок. `DiscoveryService` из NestJS автоматически находит все помеченные классы при старте приложения и регистрирует их в соответствующих менеджерах (`CommandHandler`, `ButtonManager`).
*   **`@RequiresPermission()`:** Декларативно указывает, какие права необходимы для выполнения метода команды, поддерживая логику "И" (`AND`) и "ИЛИ" (`OR`).

#### 4.5. Декларативная авторизация и "Охранники" (Guards)
Система контроля доступа построена на "Охранниках" NestJS.
*   **`PermissionGuard`** — это глобальный "охранник", который автоматически перехватывает выполнение защищенных методов. Он извлекает метаданные, установленные декоратором `@RequiresPermission`, и использует `PermissionService` для проверки соответствия пользователя требованиям.

#### 4.6. Диспетчеризация взаимодействий
Входящие взаимодействия от Discord обрабатываются по паттерну "Цепочка ответственности" (Chain of Responsibility).
*   Центральный сервис `InteractionManager` подписывается на общее событие создания взаимодействия.
*   Он определяет тип взаимодействия (`isChatInputCommand`, `isButton`, `isAutocomplete`, и т.д.).
*   Затем он передает взаимодействие первому зарегистрированному специализированному обработчику (`CommandHandler`, `ButtonManager`), который может его обработать (метод `supports()`).

## 5. Структура проекта

| Путь | Описание |
| :--- | :--- |
| `src/core.DiscordClient` | Ключевые инфраструктурные компоненты бота: `Client.ts`, **`ConfigurationService.ts` (Фасад)**, и другие глобальные сервисы. |
| `src/core.DiscordClient/core.Services/components.ConfigServices` | **Новая архитектура конфигурации:** содержит слои `storage` (стратегии) и `repository` (репозитории). |
| `src/modules` | Директория для функциональных модулей. Каждый подкаталог — это самодостаточная бизнес-функция (например, `module.GuildConfigManager`). |
| `src/handlers.Global` | Слой обработки взаимодействий. Содержит `InteractionManager` (диспетчер) и его компоненты — специализированные обработчики. |
| `src/event.EventBus` | Контракты для внутренней шины событий: `app.events.ts` (словарь имен событий) и классы-обертки для данных событий. |
| `src/decorators.NestJS` | Кастомные декораторы, используемые в приложении: `@Command` для обнаружения команд и `@RequiresPermission` для авторизации. |
| `src/guards.NestJS` | Реализации "охранников" NestJS. `PermissionGuard.ts` является ключевым компонентом системы авторизации. |
| `src/core.DiscordClient/abstractions/interface` | Директория для TypeScript-интерфейсов, которые определяют контракты для всех основных сервисов, репозиториев и стратегий. |

## 6. Автоматическая генерация документации

Проект поддерживает автоматическую генерацию технической документации из комментариев в исходном коде (JSDoc/TSDoc).

Для генерации документации необходимо выполнить следующую команду:

```bash
npm run docs:generate
```

Эта команда запускает инструмент **Compodoc**, который анализирует исходный код и создает статичный HTML-сайт с описанием всех модулей, классов, методов и их зависимостей. Результат сохраняется в директорию `documentation`.
