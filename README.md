[![TypeScript](https://img.shields.io/badge/TypeScript-3178C6?logo=typescript&logoColor=white://img.shields.io/badge/NestJS-E0234E?logo=nestjs&d](https://img.shields.io/badge/Discord-5865F2?logo=discord&logottps://img.shields.io/badge/Discord.js-2C2F33?logo=discord&logo
# Discord Бот на NestJS

## 1. Введение

Этот документ описывает архитектуру и структуру Discord-бота, построенного с использованием фреймворка **NestJS** и библиотеки **discord.js**. Проект ориентирован на модульность, расширяемость и удобство поддержки.

## 2. Ключевые архитектурные особенности

Система построена на нескольких фундаментальных концепциях.

#### 2.1. Модульность
Приложение разделено на независимые, функциональные модули NestJS. Каждый модуль (например, `GuildConfigModule`, `LoggingUserInteractionsGuildModule`) инкапсулирует определенную бизнес-логику и связанные с ней компоненты (сервисы, команды, обработчики).

#### 2.2. Внедрение зависимостей (Dependency Injection)
Фреймворк NestJS управляет жизненным циклом всех сервисов и команд через встроенный контейнер Inversion of Control (IoC). Компоненты объявляют свои зависимости в конструкторе, что позволяет фреймворку предоставлять их экземпляры автоматически.

#### 2.3. Событийно-ориентированная архитектура (Event Bus)
Взаимодействие между различными логическими слоями приложения построено на асинхронной модели "Издатель-Подписчик" с использованием внутренней шины событий (`@nestjs/event-emitter`).

**Процесс работы:**
1.  `Client.ts` (слой адаптера) прослушивает "сырые" события от Discord API.
2.  Получив событие, он оборачивает его в строго типизированный внутренний класс-событие (например, `MessageCreateEvent`) и отправляет в шину.
3.  Любой сервис в приложении подписывается на это внутреннее событие с помощью декоратора `@OnEvent`.

#### 2.4. Декларативная авторизация
Реализована система контроля доступа на основе прав (Permissions) с использованием кастомного декоратора `@RequiresPermission`.
*   **Декоратор `@RequiresPermission`** декларативно указывает, какие права необходимы для выполнения метода команды, и поддерживает логику "И" (`AND`) и "ИЛИ" (`OR`).
*   **`PermissionGuard`** — это глобальный "охранник" NestJS, который автоматически перехватывает выполнение защищенных методов. Он извлекает метаданные из декоратора и использует `PermissionService` для проверки соответствия пользователя требованиям.

#### 2.5. Диспетчеризация взаимодействий
Входящие взаимодействия от Discord обрабатываются по паттерну "Цепочка ответственности" (Chain of Responsibility).
*   Центральный сервис `InteractionManager` подписывается на общее событие создания взаимодействия.
*   Он определяет тип взаимодействия (`isChatInputCommand`, `isButton`, `isAutocomplete`, и т.д.).
*   Затем он передает взаимодействие первому зарегистрированному специализированному обработчику (`CommandHandler`, `ButtonHandler`), который может его обработать (метод `supports()`).

## 3. Структура проекта

Проект имеет строго определенную структуру каталогов для логического разделения компонентов.

| Путь | Описание |
| :--- | :--- |
| `src/core.DiscordClient` | Ключевые инфраструктурные компоненты бота: `Client.ts`, `ConfigManager.ts`, `GuildConfigManager.ts` и другие глобальные сервисы. |
| `src/modules` | Директория для функциональных модулей. Каждый подкаталог — это самодостаточная бизнес-функция (например, `module.GuildConfigManager`). |
| `src/handlers.Global` | Слой обработки взаимодействий. Содержит `InteractionManager` (диспетчер) и его компоненты — специализированные обработчики (`CommandHandler`, `ButtonHandler`). |
| `src/event.EventBus` | Контракты для внутренней шины событий: `app.events.ts` (словарь имен событий) и классы-обертки для данных событий. |
| `src/decorators.NestJS` | Кастомные декораторы, используемые в приложении: `@Command` для обнаружения команд и `@RequiresPermission` для авторизации. |
| `src/guards.NestJS` | Реализации "охранников" NestJS. `PermissionGuard.ts` является ключевым компонентом системы авторизации. |
| `src/core.DiscordClient/abstractions` | Директория для TypeScript-интерфейсов (`IClient`, `ICommand`, `IConfig`), которые определяют контракты для основных сервисов и сущностей. |

## 4. Автоматическая генерация документации

Проект поддерживает автоматическую генерацию технической документации из комментариев в исходном коде (JSDoc/TSDoc).

Для генерации документации необходимо выполнить следующую команду:

```bash
npm run docs:generate
```

Эта команда запускает инструмент **Compodoc**, который анализирует исходный код и создает статичный HTML-сайт с описанием всех модулей, классов, методов и их зависимостей. Результат сохраняется в директорию `documentation`.
