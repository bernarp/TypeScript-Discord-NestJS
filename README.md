
# Архитектура

## 1. Ключевые Принципы

Проект построен на следующих принципах:

-   **Объектно-Ориентированное Программирование (ООП)**: Используются классы и объекты для моделирования сущностей.
-   **SOLID**:
    -   **S (Single Responsibility)**: Каждый класс имеет одну зону ответственности. Пример: `MessageDeleteLogger` отвечает только за логирование удалений.
    -   **O (Open/Closed)**: Система спроектирована для расширения нового функционала без модификации существующего кода.
    -   **L (Liskov Substitution)**: Дочерние классы могут заменять родительские (абстрактные) классы без нарушения работы системы.
    -   **I (Interface Segregation)**: Используются небольшие, сфокусированные интерфейсы (`IConfig`, `IClient`).
    -   **D (Dependency Inversion)**: Модули зависят от абстракций, а не от конкретных реализаций.
-   **Внедрение Зависимостей (Dependency Injection, DI)**: Зависимости предоставляются классам через конструктор с помощью DI-контейнера NestJS, а не создаются внутри них.
-   **Don't Repeat Yourself (DRY)**: Общая логика выносится в переиспользуемые компоненты, такие как абстрактные классы (`AbstractMessageLogger`).

## 2. Компоненты Архитектуры

Проект использует фреймворк **NestJS**.

### 2.1. Модули (`*.module.ts`)

Модули группируют связанные компоненты.

-   `AppModule`: Корневой модуль, собирающий приложение.
-   `CoreModule`: Глобальный модуль, предоставляющий общие сервисы (`IConfig`, `IClient`, `IEmbedFactory`).
-   **Функциональные модули**: Группируют компоненты по функциональному признаку. Например, `LoggingUserInteractionsGuildModule` содержит все сервисы, связанные с логированием.

### 2.2. Сервисы (`*.service.ts`)

Сервисы инкапсулируют бизнес-логику.

-   **Фундаментальные сервисы**:
    -   `ConfigManager`: Управляет конфигурацией из `.env` файла.
    -   `Client`: Обертка над `discord.js Client`. Слушает события от Discord API и транслирует их во внутреннюю шину событий.
    -   `GuildConfigManager`: Управляет конфигурацией для каждой гильдии.
-   **Сервисы-Логгеры**:
    -   `AbstractMessageLogger`: Абстрактный класс с общей логикой для всех логгеров сообщений.
    -   `InteractionLogger...`: Конкретные реализации логгеров, которые обрабатывают определенные события.

### 2.3. Команды (`*.command.ts`)

Каждая слеш-команда — это отдельный класс с декоратором `@Command()`.

-   `CommandHandlerService`: Обнаруживает, регистрирует и выполняет все команды.
-   **Логирование команд**: `CommandHandlerService` генерирует событие `INTERACTION_CREATED_COMMAND` после выполнения команды, которое обрабатывается соответствующим логгером.

### 2.4. Шина Событий (`Event Bus`)

Механизм для взаимодействия между компонентами без прямой связи.

-   **Источник событий**: `Client` получает события от Discord API и генерирует внутренние доменные события (например, `MessageDeleteEvent`).
-   **Слушатели событий**: Сервисы подписываются на события с помощью декоратора `@OnEvent()`.

**Поток данных на примере логирования удаления сообщения:**

1.  `discord.js` генерирует событие `Events.MessageDelete`.
2.  `Client` перехватывает его.
3.  `Client` создает `new MessageDeleteEvent(message)` и отправляет в шину событий через `eventEmitter.emit()`.
4.  `InteractionLoggerDeleteMessageUser` (слушатель события) активируется.
5.  Логгер получает конфигурацию, формирует embed и отправляет его.

## 3. Структура Проекта

```
src
├── core.DiscordClient/ # Фундаментальные классы и абстракции
│ ├── abstractions/ # Абстрактные классы и интерфейсы (IClient, IConfig)
│ ├── core.DiscordClient/ # Реализации (Client, GuildConfigManager)
│ └── utils.Global/ # Глобальные утилиты (EmbedFactory)
│
├── event.EventBus/ # Компоненты шины событий
│ ├── app.events.ts # Ключи всех событий
│ └── \*.event.ts # Классы данных событий
│
├── handlers.Global/ # Обработчики (CommandManager)
│
├── modules/ # Функциональные модули
│ └── modules.DiscordClient/
│ ├── example/ # Пример модуля
│ └── logging.UserInteractionsGuild/
│ ├── services/ # Сервисы-логгеры
│ └── logging.user-interactions.module.ts
│
├── app.module.ts # Корневой модуль
├── core.module.ts # Глобальный модуль
└── main.ts # Точка входа
```


## 4. Алгоритм добавления нового функционала

**Пример: Добавить логирование бана пользователя.**

1.  **Событие**:
    -   В `app.events.ts` добавить ключ `MEMBER_BANNED`.
    -   Создать файл `guild-member-ban.event.ts` с классом `GuildMemberBanEvent`.
2.  **Источник**:
    -   В `Client.ts` подписаться на событие `Events.GuildBanAdd`.
    -   В обработчике генерировать и отправлять `new GuildMemberBanEvent(ban)`.
3.  **Конфигурация**:
    -   В `IGuildConfig.ts` добавить поле `logChannelMemberBanId?: string;`.
    -   В `ConfigCommand.ts` добавить опцию для управления этой настройкой.
4.  **Логика**:
    -   Создать сервис `MemberBanLogger.service.ts`.
    -   Унаследовать его от подходящего абстрактного класса или создать новый.
    -   Реализовать метод с декоратором `@OnEvent(AppEvents.MEMBER_BANNED)`.
    -   В методе реализовать логику получения конфигурации и отправки лога.
5.  **Регистрация**:
    -   Добавить `MemberBanLogger` в массив `providers` в соответствующем модуле (например, `logging.user-interactions.module.ts`).

